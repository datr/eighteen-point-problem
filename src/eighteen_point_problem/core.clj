(ns eighteen-point-problem.core
  (:refer-clojure :exclude [==])
  (:use clojure.core.logic))

(def sections [0 720720 765765 816816 875160 942480 1021020 1113840 1225224 1361360 1441440 1531530 1633632 1750320 1884960 2042040 2162160 2227680 2297295 2450448 2625480 2722720 2827440 2882880 3063060 3267264 3341520 3500640 3603600 3675672 3769920 3828825 4084080 4324320 4375800 4455360 4594590 4712400 4900896 5045040 5105100 5250960 5360355 5445440 5569200 5654880 5717712 5765760 6126120 6486480 6534528 6597360 6683040 6806800 6891885 7001280 7147140 7207200 7351344 7539840 7657650 7796880 7876440 7927920 8168160 8423415 8482320 8576568 8648640 8751600 8910720 8984976 9189180 9369360 9424800 9529520 9626760 9801792 9954945 10024560 10090080 10210200 10367280 10501920 10618608 10720710 10810800 10890880 11027016 11138400 11231220 11309760 11377080 11435424 11486475 11531520])

(defn test-sub-set [n i vars]
  (fresh [a]
    (conde
      [(== i n)]
      [(membero a (filter #(< % (* (+ i 1) 12252240 (/ 1 n))) (filter #(>= % (* i 12252240 (/ 1 n))) sections)))
       (membero a vars)
       (test-sub-set n (+ i 1) vars)])))

(defn conditions [n vars]
  (conde
    [(== n 18)]
    [(test-sub-set n 0 (subvec vars 0 n))
     (conditions (+ n 1) vars)]))

(defn solution []
  (run* [a b c d e f g h i j k l m n o p q]
    (conditions 2 [a b c d e f g h i j k l m n o p q])))